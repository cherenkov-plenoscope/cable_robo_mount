import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from .optical_geometry import z_hybrid


def lengths_of_bars(geom):

    lengths = []
    for i in range(geom['bars'].shape[0]):
        try:
            start, end = cartesian_start_and_end_of_bar(geom, i)
            lengths.append(np.linalg.norm(end - start))
        except IndexError:
            pass
    return np.array(lengths)

def flat_node_index(nodes,i,j,k):
    nis = nodes.shape[0]
    njs = nodes.shape[1]
    nks = nodes.shape[2]
    return i*nks*njs + j*nks + k


def to_vtk_mesh(path, nodes, bars):

    number_of_nodes = nodes.shape[0]*nodes.shape[1]*nodes.shape[2]
    vtk = '# vtk DataFile Version 2.0\n'
    vtk+= 'generated by TheBigLebowsky\n'
    vtk+= 'ASCII\n'
    vtk+= 'DATASET UNSTRUCTURED_GRID\n'
    vtk+= 'POINTS '+str(number_of_nodes)+' float\n'

    for i in range(nodes.shape[0]):
        for j in range(nodes.shape[1]):
            for k in range(nodes.shape[2]):
                vtk+= str(nodes[i,j,k,0])+' '
                vtk+= str(nodes[i,j,k,1])+' '
                vtk+= str(nodes[i,j,k,2])+'\n'

    number_of_bars = bars.shape[0]
    vtk += 'CELLS '+str(number_of_bars)+' '+str(2*number_of_bars)+'\n'
    for bar in bars:
        start_node_index = flat_node_index(nodes, bar[0,0], bar[0,1], bar[0,2])
        end_node_index = flat_node_index(nodes, bar[1,0], bar[1,1], bar[1,2])
        vtk+= '2 '+str(start_node_index)+' '+str(end_node_index)+'\n'

    vtk_file = open(path, "w")
    vtk_file.write(vtk)
    vtk_file.close()

def plot_geometry(geometry):
    nodes = geometry['nodes']
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')

    for bar in geometry['bars']:
        try:
            start_position = nodes[bar[0,0], bar[0,1], bar[0,2]]
            end_position = nodes[bar[1,0], bar[1,1], bar[1,2]]

            ax.plot(
                [start_position[0], end_position[0]],
                [start_position[1], end_position[1]],
                [start_position[2], end_position[2]],'b')
        except IndexError:
            pass

    """
    nodes_flat = []
    for i in range(nodes.shape[0]):
        for j in range(nodes.shape[1]):
            for k in range(nodes.shape[2]):
                nodes_flat.append(nodes[i,j,k,:])
    nodes_flat = np.array(nodes_flat)

    ax.scatter(
        nodes_flat[:,0],
        nodes_flat[:,1],
        nodes_flat[:,2],
        'or')
    """

    if geometry['mirror_tripods'] is not None:
        for mirror_tripod in geometry['mirror_tripods']:
            try:
                mt = mirror_tripod
                n1 = nodes[mt[0,0], mt[0,1], mt[0,2]]
                n2 = nodes[mt[1,0], mt[1,1], mt[1,2]]
                n3 = nodes[mt[2,0], mt[2,1], mt[2,2]]
                ax.plot(
                    [n1[0], n2[0]],
                    [n1[1], n2[1]],
                    [n1[2], n2[2]],'r',linewidth=3.0)
                ax.plot(
                    [n2[0], n3[0]],
                    [n2[1], n3[1]],
                    [n2[2], n3[2]],'r',linewidth=3.0)
                ax.plot(
                    [n3[0], n1[0]],
                    [n3[1], n1[1]],
                    [n3[2], n1[2]],'r',linewidth=3.0)
            except IndexError:
                pass
    plt.show()


#nodes_mask = np.ones(shape=(nodes.shape[0], nodes.shape[1], nodes.shape[2]), dtype=np.bool)
#bars_mask = np.ones(shape=(bars.shape[0]), dtype=np.bool)
